# **Database**

---

## **ORM** _**O**bject-**R**elational **M**apping_

데이터베이스의 테이블을 객체 데이터 타입으로 매핑하여  
개발자가 프로그래밍 언어를 사용해 데이터베이스 작업(CRUD)을 수행할 수 있게 해주는 도구이다.  
즉, SQL 쿼리를 직접 작성하지 않고도  
프로그래밍 언어를 통해 데이터를 **생성(Create), 조회(Read), 수정(Update), 삭제(Delete)**할 수 있다.

### 데이터베이스란?

데이터베이스는 데이터를 저장하고 관리하는 체계적인 구조를 뜻한다.  
보통 테이블(table) 형태로 데이터를 저장하며,  
테이블은 **행(row)**과 **열(column)**으로 구성됩니다.

- 객체와 매핑되는 경우
  - 테이블의 열(column) → 테이블에 저장된 데이터의 속성으로, 객체의 하나의 key에 해당
  - 테이블의 행(row) → 각각의 열(속성)에 대한 데이터들을 포함하는 하나의 완전한 레코드로, 객체의 한 인스턴스에 해당

### ORM의 장점

- **생산성 향상**  
  SQL을 직접 작성할 필요 없이 프로그래밍 언어로 데이터 작업을 처리할 수 있어 개발 시간 단축됨
- **유지보수 용이성**  
  데이터베이스와 관련된 작업이 코드화되어 있어 변경 사항을 관리가 용이함
- **데이터베이스 독립성**  
  하나의 ORM 코드로 여러 데이터베이스에서 작업을 수행할 수 있으므로, 데이터베이스를 교체할 때도 코드 수정이 최소화됨
- **보안 향상**  
  사용자의 입력 값은 SQL 쿼리 내의 코드가 아닌 프로그래밍 언어의 데이터로 처리되기 때문에  
  SQL Injection과 같은 보안 위협을 효과적으로 방지 가능
- **직관적인 코드**  
  객체 중심의 코드로 데이터베이스와 상호작용하므로 코드의 가독성 향상

---

## **Prisma**

Prisma는 **Node.js**와 **Typescript**를 위한 **ORM** 도구

### Prisma 세 가지 주요 구성 요소

- **Prisma Client**  
  데이터베이스 쿼리를 위한 자동 생성된 TypeScript/JavaScript 클라이언트
- **Prisma Schema**  
  데이터 모델 정의를 위한 스키마 파일
- **Prisma Migrate**  
  데이터베이스 마이그레이션 관리 도구

### Prisma 장점

- **강력한 타입 지원**  
  TypeScript 통합을 통해 컴파일 단계에서 데이터 모델 관련 오류를 사전에 방지 가능
- **자동 생성된 클라이언트**  
  Prisma Client를 사용하면 코드 자동 완성, 타입 검사, 안전한 데이터베이스 쿼리 생성 가능
- **마이그레이션 관리**  
  Prisma Migrate를 사용하여 데이터베이스의 체계적인 스키마 변경 가능
- **데이터 모델 기반 접근**  
  Prisma Schema를 기반으로 데이터 모델을 정의하면 개발과 데이터베이스 간의 간격을 줄이고 일관성 유지가 쉬움
- **다양한 데이터베이스 지원**  
  MySQL, PostgreSQL, MongoDB, SQLite 등 여러 데이터베이스와 호환
- **직관적인 API**  
  읽기 쉽고 간결한 API를 제공하여 데이터베이스 작업이 편리함

---

## **3-Tier Architecture**

- **3-Tier 아키텍처란?**  
  애플리케이션을 세 가지 계층(Tier)으로 나누어 구조화하는 소프트웨어 설계 방식

- 세 가지 계층 종류
  - **클라이언트 계층**  
    **사용자 인터페이스 _UI_** 를 제공하여 사용자와 상호작용
  - **비즈니스 로직 계층**  
    애플리케이션의 핵심 **로직**을 처리
  - **데이터 계층**  
    **데이터베이스**와 관련된 작업을 담당

### **1-Tier 아키텍처**

- **구성**  
  애플리케이션의 모든 요소(UI, 로직, 데이터)가 한 시스템에 통합

- 장점
  - **간단한 구현**  
    개발 및 배포가 간단하며 유지보수가 쉬움
  - **낮은 초기 비용**  
    별도의 네트워크 구성이 필요하지 않아 비용이 적음
  - **빠른 속도**  
    모든 작업이 로컬에서 수행되므로 속도가 빠름
- 단점
  - **확장성 부족**  
    여러 사용자가 동시에 사용하기 어려움
  - **취약한 데이터 보안**  
    데이터와 로직이 동일한 시스템에 존재해 위험 증가
  - **어려운 유지보수**  
    모든 기능이 하나로 통합되어 있어 수정이 어렵고 복잡

### **2-Tier 아키텍처**

- 구성  
  **클라이언트 계층** + **데이터베이스 계층**

  - 클라이언트 계층: UI와 일부 비즈니스 로직 처리
  - 데이터베이스 계층: 데이터 관리

- 장점

  - **분리된 데이터베이스**  
    데이터베이스가 분리되어 데이터 관리를 효율적으로 수행
  - **부분적 확장성**  
    여러 클라이언트를 추가하여 다수의 사용자가 데이터베이스에 접근 가능
  - **모듈화**  
    데이터와 UI가 분리되어 체계적 설계 가능

- 단점
  - **비즈니스 로직의 위치**  
    클라이언트에 로직을 포함하면 클라이언트가 무거워지고,  
    데이터베이스에 포함하면 확장성 부족
  - **네트워크 의존성**  
    클라이언트와 데이터베이스 간 통신에 네트워크가 필수
  - **확장성 한계**  
    로직이 클라이언트와 데이터베이스에 분산되어 서버 부하를 줄이기 어려움

### **3-Tier 아키텍처**

- 구성  
  **클라이언트 계층** + **비즈니스 계층** + **데이터 계층**

  - 클라이언트 계층: 사용자 인터페이스(UI)를 담당
  - 비즈니스 계층: 비즈니스 로직 처리
  - 데이터 계층: 데이터베이스 관리

- 장점

  - **유지보수**  
    각 계층이 독립적이라 수정 및 유지보수가 쉬움
  - **확장성**  
    각 계층을 독립적으로 확장 가능
  - **보안 강화**  
    데이터 계층과 클라이언트 계층이 직접 연결되지 않아 보안성이 높음
  - **다양한 클라이언트 지원**  
    다양한 클라이언트(UI)와 쉽게 통합 가능

- 단점
  - **복잡한 구현**  
    설계와 구현이 1-Tier 또는 2-Tier보다 복잡
  - **높은 초기 비용**  
    여러 계층을 구성하고 관리해야 하므로 초기 비용이 높음
  - **성능 저하 가능성**  
    계층 간 통신으로 인해 처리 속도가 느려질 가능성
