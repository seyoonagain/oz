# **React & Redux**

---

### **컴포넌트의 생명주기**

`Mount(화면에 그려짐)` → `Update(내용 업데이트)` → `Unmount(화면에서 사라짐)`

---

### **클래스형 컴포넌트 vs. 함수형 컴포넌트**

#### **클래스 컴포넌트 생명주기**

1. 클래스 생성

2. 화면에 표시될 때 클래스 컴포넌트의 인스턴스가 생성되면서 **Mount**

3. 인스턴스 내 상태 값이 변하면 화면 **Update**

4. 화면에서 더 이상 쓰지 않으면 **Unmount**되면서 인스턴스 삭제

#### **함수 컴포넌트 생명주기**

1. 함수 정의

2. 화면에 표시될 때 함수 컴포넌트 호출되면서 **Mount**

3. 상태 값이 변하면, **기존 함수를 사용하지 않고** 새로운 상태 값으로 함수 다시 호출해서 화면 **Update**

   > 여기서 생긴 궁금증 💭  
   > "함수를 다시 호출하면 상태 값이 `useState`에 설정된 초기값으로 바뀌는 거 아닌가?" 싶었지만 그렇지 않다.  
   > `useState`로 설정한 초기값은 **Mount 될 때 한 번만 사용**되고,  
   > Update 될 때는 바뀐 상태 값으로 화면을 리렌더링한다.

4. 화면에서 더 이상 쓰지 않는 경우, **Unmount**되면서 함수 호출 종료

---

### **클래스형 컴포넌트의 생명주기 메서드**

- `componentDidMount()`
- `componentDidUpdate()`
- `componentDidUnmount()`

[참고사이트](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

---

### **componentDidMount()**

- 실행 시점  
  클래스 컴포넌트가 인스턴스를 생성되고, 마운트되면서 `render()` 함수가 실행된 후,
  DOM에 컴포넌트에 삽입이 완료된 시점, 즉, **렌더링이 완료된 후** `componentDidMount()`가 실행된다.

<br>

#### `componentDidMount()`에서 주로 수행하는 동작

- API 호출
- 타이머 설정
- DOM 조작

---

### **componentDidUpdate()**

- 실행 시점  
  클래스 컴포넌트의 상태나 속성 값이 변경되면 `render()` 함수가 다시 실행되어 새로운 상태 값으로 DOM 업데이트를 완료한 후,  
  `componentDidUpdate()`가 실행된다.

<br>

#### `componentDidUpdate()`에서 주로 수행하는 동작

- 변경된 상태에 따른 추가 작업
- 리렌더링 후 DOM 조작

---

### **componentWillUnmount()**

- 실행 시점  
  클래스 컴포넌트가 화면에서 사라지기 직전에 `componentWillUnmount()`가 실행되며,  
  주로 리소스 정리를 처리한다.

<br>

#### `componentWillUnmount()`에서 주로 수행하는 동작

- 타이머 제거
- 이벤트 리스너 제거
- 외부 데이터 구독 해제

---

### **함수형 컴포넌트의 생명주기 훅**

- **`useEffect()`**  
  함수형 컴포넌트에서 **주로 사용하는 훅**으로,  
  클래스형 컴포넌트의 생명주기 메서드인 `componentDidMount()`, `componentDidUpdate()`, `componentWillUnmount()`의 역할을 하나의 훅으로 대체할 수 있다.

- **`useLayoutEffect()`**  
  `useEffect()`와 비슷하지만, **DOM이 업데이트된 직후에 동기적으로 실행**된다.  
  따라서 레이아웃이나 화면에 즉각적인 변화를 주는 작업을 할 때 사용한다.

---

### **useEffect()**

`useEffect()` 안에는 두 개의 인자를 쓸 수 있다.

- 첫 번째 인자: **콜백함수**  
   컴포넌트가 **mount**될 때,  
   또는 의존성 배열에 전달된 상태 값이 **update**될 때 실행할 함수를 작성한다.  
   콜백함수가 함수를 리턴하게 되면, 그 함수는 컴포넌트가 **unmount**되기 직전에 실행되며,  
   이는 클래스형 컴포넌트의 `componentWillUnmount()`와 같은 역할이라고 볼 수 있다.

- 두 번째 인자(optional): **의존성 배열**  
   의존성 배열에 포함된 state, props, 함수 등이 변경이 되면 `useEffect()`의 콜백함수가 실행된다.

```jsx
useEffect(() => {
  // 초기 렌더링(mount) 또는 의존성 배열에 있는 값 변경 시(update) 실행할 함수
  return () => {
    // unmount 시 실행할 함수
  };
}, []);
```

#### **의존성 배열**

- **의존성 배열에 요소가 있는 경우**  
   컴포넌트가 **mount** 되었을 때, (_componentDidMount()_)  
   그리고 배열 속 요소의 값이 변경되어 컴포넌트가 **update**될 때마다, (_componentDidUpdate()_)  
   렌더링 후 `useEffect()`의 콜백함수가 실행된다.

- **의존성 배열이 빈 배열인 경우**  
   컴포넌트가 처음 **mount**될 때만 `useEffect()`의 콜백함수가 실행된다. (_componentDidMount()_)

- **의존성 배열을 전달하지 않은 경우**  
   컴포넌트가 **mount** 되었을 때, (_componentDidMount()_)  
   그리고 컴포넌트가 **update**될 때마다, (_componentDidUpdate()_)  
   렌더링 후 `useEffect()`의 콜백함수가 실행된다.  
   `useEffect()`를 사용하지 않고 컴포넌트 내부에 작성한 함수는 렌더링 도중 실행되지만,  
   `useEffect()`로 감싸준 콜백함수는 렌더링이 다 끝나고 난 뒤 실행된다는 차이가 있다.

---

#### **클린업 함수**

`useEffect()` 내 콜백함수가 리턴하는 함수를 클린업 함수라고 부르며,  
클린업 함수는 컴포넌트가 **unmount**될 때마다 실행된다.

- 클린업 함수의 주된 목적: **메모리 누수 방지 및 불필요한 동작 방지**

클래스 컴포넌트의 `componentWillUnmount()`와 마찬가지로 주로 다음과 같은 동작들을 수행한다.

- 타이머 제거
- 이벤트 리스너 제거
- 외부 데이터 구독 해제

컴포넌트가 마운트되고 실행되었던 것들을 제거시키는 동작을 수행하여, **클린업 함수**라고 부른다.

<br>

이 때, 의존성 배열을 전달하지 않아 모든 상태 변화에 대해 **update**가 일어나거나,  
의존성 배열에 들어있는 특정 값에 의해 **update**가 일어나면,  
기존 컴포넌트는 **unmount**되어 콜백함수의 리턴함수가 실행되고,  
새로운 상태값으로 만든 컴포넌트가 **mount**되면서 콜백함수가 재실행된다.
만약 첫 **mount**와 최종 **unmount** 시에만 콜백함수를 실행하고자 한다면,  
의존성 배열을 빈 배열로 전달하면 된다.

---

### **생명주기 함수 필요성**

생명주기 함수/훅을 이용한 사이드 이펙트 처리 및 클린업 함수를 통한 리소스 관리를 통해 성능을 최적화할 수 있다.

#### **사이드 이펙트별 생명주기 함수 사용의 효과**

- **서버에서 데이터를 받아오는 경우**

  - **생명주기 함수 사용 전:**  
    렌더링 전에 데이터를 가져오지 못해 화면에 표시되지 않거나,  
    리렌더링될 때마다 데이터를 요청하여 불필요한 네트워크 트래픽이 발생할 수 있다.
  - **생명주기 함수 사용 효과:**  
    `useEffect()`를 사용하여 렌더링이 끝난 후 데이터를 요청하고,  
    데이터 수신 후 관련 상태를 업데이트함으로써 리렌더링을 통해 화면에 데이터를 표시할 수 있다.  
    또한 의존성 배열을 빈 배열로 설정하여 최초 렌더링 시에만 데이터를 요청하도록 하여 불필요한 네트워크 요청을 방지할 수 있다.  
    이를 통해 비동기 데이터 요청에서 발생할 수 있는 오류를 효과적을 관리할 수 있다.

- **이벤트 핸들러를 사용하는 경우**

  - **생명주기 함수 사용 전:**  
    `addEventListener()`를 이용하여 이벤트를 추가하는 경우,  
    컴포넌트가 리렌더링될 때마다 이벤트 리스너가 중복으로 추가되어 불필요한 메모리 사용을 초래할 수 있다.
  - **생명주기 함수 사용 효과:**  
    `useEffect()` 내에서 이벤트 핸들러를 등록하고,  
     컴포넌트가 언마운트될 때, `removeEventListener()`을 호출하여  
     메모리 누수를 방지하고 불필요한 이벤트 호출을 막을 수 있다.

- **타이머 함수를 사용하는 경우**

  - **생명주기 함수 사용 전:**  
    타이머가 리렌더링 될 때마다 추가되어 여러 개의 타이머가 실행되는 상황이 발생할 수 있다.
  - **생명주기 함수 사용 효과:**  
    `setTimeout()`이나 `setInterval()`을 사용하여 타이머를 설정하고,  
    언마운트 시, 클린업 함수에서 이를 제거함으로써 리렌더링시 불필요한 타이머 중복 실행을 방지할 수 있다.
